import { createManualModuleSource } from '@vitest/mocker/node';

const playwrightBrowsers = [
	"firefox",
	"webkit",
	"chromium"
];
class PlaywrightBrowserProvider {
	name = "playwright";
	supportsParallelism = true;
	browser = null;
	browserName;
	project;
	options;
	contexts = new Map();
	pages = new Map();
	browserPromise = null;
	mocker;
	getSupportedBrowsers() {
		return playwrightBrowsers;
	}
	initialize(project, { browser, options }) {
		this.project = project;
		this.browserName = browser;
		this.options = options;
		this.mocker = this.createMocker();
	}
	async openBrowser() {
		if (this.browserPromise) {
			return this.browserPromise;
		}
		if (this.browser) {
			return this.browser;
		}
		this.browserPromise = (async () => {
			const options = this.project.config.browser;
			const playwright = await import('playwright');
			const launchOptions = {
				...this.options?.launch,
				headless: options.headless
			};
			if (this.project.config.inspector.enabled) {
				const port = this.project.config.inspector.port || 9229;
				const host = this.project.config.inspector.host || "127.0.0.1";
				launchOptions.args ||= [];
				launchOptions.args.push(`--remote-debugging-port=${port}`);
				launchOptions.args.push(`--remote-debugging-address=${host}`);
				this.project.vitest.logger.log(`Debugger listening on ws://${host}:${port}`);
			}
			if (this.project.config.browser.ui && this.browserName === "chromium") {
				if (!launchOptions.args) {
					launchOptions.args = [];
				}
				if (!launchOptions.args.includes("--start-maximized") && !launchOptions.args.includes("--start-fullscreen")) {
					launchOptions.args.push("--start-maximized");
				}
			}
			const browser = await playwright[this.browserName].launch(launchOptions);
			this.browser = browser;
			this.browserPromise = null;
			return this.browser;
		})();
		return this.browserPromise;
	}
	createMocker() {
		const idPreficates = new Map();
		const sessionIds = new Map();
		function createPredicate(sessionId, url) {
			const moduleUrl = new URL(url, "http://localhost");
			const predicate = (url) => {
				if (url.searchParams.has("_vitest_original")) {
					return false;
				}
				if (url.pathname !== moduleUrl.pathname) {
					return false;
				}
				url.searchParams.delete("t");
				url.searchParams.delete("v");
				url.searchParams.delete("import");
				if (url.searchParams.size !== moduleUrl.searchParams.size) {
					return false;
				}
				for (const [param, value] of url.searchParams.entries()) {
					if (moduleUrl.searchParams.get(param) !== value) {
						return false;
					}
				}
				return true;
			};
			const ids = sessionIds.get(sessionId) || [];
			ids.push(moduleUrl.href);
			sessionIds.set(sessionId, ids);
			idPreficates.set(moduleUrl.href, predicate);
			return predicate;
		}
		return {
			register: async (sessionId, module) => {
				const page = this.getPage(sessionId);
				await page.route(createPredicate(sessionId, module.url), async (route) => {
					if (module.type === "manual") {
						const exports = Object.keys(await module.resolve());
						const body = createManualModuleSource(module.url, exports);
						return route.fulfill({
							body,
							headers: getHeaders(this.project.browser.vite.config)
						});
					}
					const isWebkit = this.browserName === "webkit";
					if (isWebkit) {
						const url = module.type === "redirect" ? (() => {
							const url = new URL(module.redirect);
							return url.href.slice(url.origin.length);
						})() : (() => {
							const url = new URL(route.request().url());
							url.searchParams.set("mock", module.type);
							return url.href.slice(url.origin.length);
						})();
						const result = await this.project.browser.vite.transformRequest(url).catch(() => null);
						if (!result) {
							return route.continue();
						}
						let content = result.code;
						if (result.map && "version" in result.map && result.map.mappings) {
							const type = isDirectCSSRequest(url) ? "css" : "js";
							content = getCodeWithSourcemap(type, content.toString(), result.map);
						}
						return route.fulfill({
							body: content,
							headers: getHeaders(this.project.browser.vite.config)
						});
					}
					if (module.type === "redirect") {
						return route.fulfill({
							status: 302,
							headers: { Location: module.redirect }
						});
					} else if (module.type === "automock" || module.type === "autospy") {
						const url = new URL(route.request().url());
						url.searchParams.set("mock", module.type);
						return route.fulfill({
							status: 302,
							headers: { Location: url.href }
						});
					} else ;
				});
			},
			delete: async (sessionId, id) => {
				const page = this.getPage(sessionId);
				const predicate = idPreficates.get(id);
				if (predicate) {
					await page.unroute(predicate).finally(() => idPreficates.delete(id));
				}
			},
			clear: async (sessionId) => {
				const page = this.getPage(sessionId);
				const ids = sessionIds.get(sessionId) || [];
				const promises = ids.map((id) => {
					const predicate = idPreficates.get(id);
					if (predicate) {
						return page.unroute(predicate).finally(() => idPreficates.delete(id));
					}
					return null;
				});
				await Promise.all(promises).finally(() => sessionIds.delete(sessionId));
			}
		};
	}
	async createContext(sessionId) {
		if (this.contexts.has(sessionId)) {
			return this.contexts.get(sessionId);
		}
		const browser = await this.openBrowser();
		const { actionTimeout,...contextOptions } = this.options?.context ?? {};
		const options = {
			...contextOptions,
			ignoreHTTPSErrors: true
		};
		if (this.project.config.browser.ui) {
			options.viewport = null;
		}
		const context = await browser.newContext(options);
		if (actionTimeout) {
			context.setDefaultTimeout(actionTimeout);
		}
		this.contexts.set(sessionId, context);
		return context;
	}
	getPage(sessionId) {
		const page = this.pages.get(sessionId);
		if (!page) {
			throw new Error(`Page "${sessionId}" not found in ${this.browserName} browser.`);
		}
		return page;
	}
	getCommandsContext(sessionId) {
		const page = this.getPage(sessionId);
		return {
			page,
			context: this.contexts.get(sessionId),
			frame() {
				return new Promise((resolve, reject) => {
					const frame = page.frame("vitest-iframe");
					if (frame) {
						return resolve(frame);
					}
					const timeout = setTimeout(() => {
						const err = new Error(`Cannot find "vitest-iframe" on the page. This is a bug in Vitest, please report it.`);
						reject(err);
					}, 1e3).unref();
					page.on("frameattached", (frame) => {
						clearTimeout(timeout);
						resolve(frame);
					});
				});
			},
			get iframe() {
				return page.frameLocator("[data-vitest=\"true\"]");
			}
		};
	}
	async openBrowserPage(sessionId) {
		if (this.pages.has(sessionId)) {
			const page = this.pages.get(sessionId);
			await page.close();
			this.pages.delete(sessionId);
		}
		const context = await this.createContext(sessionId);
		const page = await context.newPage();
		this.pages.set(sessionId, page);
		if (process.env.VITEST_PW_DEBUG) {
			page.on("requestfailed", (request) => {
				console.error("[PW Error]", request.resourceType(), "request failed for", request.url(), "url:", request.failure()?.errorText);
			});
		}
		return page;
	}
	async openPage(sessionId, url, beforeNavigate) {
		const browserPage = await this.openBrowserPage(sessionId);
		await beforeNavigate?.();
		await browserPage.goto(url, { timeout: 0 });
	}
	async getCDPSession(sessionid) {
		const page = this.getPage(sessionid);
		const cdp = await page.context().newCDPSession(page);
		return {
			async send(method, params) {
				const result = await cdp.send(method, params);
				return result;
			},
			on(event, listener) {
				cdp.on(event, listener);
			},
			off(event, listener) {
				cdp.off(event, listener);
			},
			once(event, listener) {
				cdp.once(event, listener);
			}
		};
	}
	async close() {
		const browser = this.browser;
		this.browser = null;
		await Promise.all([...this.pages.values()].map((p) => p.close()));
		this.pages.clear();
		await Promise.all([...this.contexts.values()].map((c) => c.close()));
		this.contexts.clear();
		await browser?.close();
	}
}
function getHeaders(config) {
	const headers = { "Content-Type": "application/javascript" };
	for (const name in config.server.headers) {
		headers[name] = String(config.server.headers[name]);
	}
	return headers;
}
function getCodeWithSourcemap(type, code, map) {
	if (type === "js") {
		code += `\n//# sourceMappingURL=${genSourceMapUrl(map)}`;
	} else if (type === "css") {
		code += `\n/*# sourceMappingURL=${genSourceMapUrl(map)} */`;
	}
	return code;
}
function genSourceMapUrl(map) {
	if (typeof map !== "string") {
		map = JSON.stringify(map);
	}
	return `data:application/json;base64,${Buffer.from(map).toString("base64")}`;
}
const CSS_LANGS_RE = /\.(?:css|less|sass|scss|styl|stylus|pcss|postcss|sss)(?:$|\?)/;
const directRequestRE = /[?&]direct\b/;
function isDirectCSSRequest(request) {
	return CSS_LANGS_RE.test(request) && directRequestRE.test(request);
}

const webdriverBrowsers = [
	"firefox",
	"chrome",
	"edge",
	"safari"
];
class WebdriverBrowserProvider {
	name = "webdriverio";
	supportsParallelism = false;
	browser = null;
	browserName;
	project;
	options;
	getSupportedBrowsers() {
		return webdriverBrowsers;
	}
	async initialize(ctx, { browser, options }) {
		this.project = ctx;
		this.browserName = browser;
		this.options = options;
	}
	async switchToTestFrame() {
		const page = this.browser;
		if (page.switchFrame) {
			await page.switchFrame(page.$("iframe[data-vitest]"));
		} else {
			const iframe = await page.findElement("css selector", "iframe[data-vitest]");
			await page.switchToFrame(iframe);
		}
	}
	async switchToMainFrame() {
		const page = this.browser;
		if (page.switchFrame) {
			await page.switchFrame(null);
		} else {
			await page.switchToParentFrame();
		}
	}
	getCommandsContext() {
		return { browser: this.browser };
	}
	async openBrowser() {
		if (this.browser) {
			return this.browser;
		}
		const options = this.project.config.browser;
		if (this.browserName === "safari") {
			if (options.headless) {
				throw new Error("You've enabled headless mode for Safari but it doesn't currently support it.");
			}
		}
		const { remote } = await import('webdriverio');
		this.browser = await remote({
			...this.options,
			logLevel: "error",
			capabilities: this.buildCapabilities()
		});
		return this.browser;
	}
	buildCapabilities() {
		const capabilities = {
			...this.options?.capabilities,
			browserName: this.browserName
		};
		const headlessMap = {
			chrome: ["goog:chromeOptions", ["headless", "disable-gpu"]],
			firefox: ["moz:firefoxOptions", ["-headless"]],
			edge: ["ms:edgeOptions", ["--headless"]]
		};
		const options = this.project.config.browser;
		const browser = this.browserName;
		if (browser !== "safari" && options.headless) {
			const [key, args] = headlessMap[browser];
			const currentValues = (this.options?.capabilities)?.[key] || {};
			const newArgs = [...currentValues.args || [], ...args];
			capabilities[key] = {
				...currentValues,
				args: newArgs
			};
		}
		if (options.ui && (browser === "chrome" || browser === "edge")) {
			const key = browser === "chrome" ? "goog:chromeOptions" : "ms:edgeOptions";
			const args = capabilities[key]?.args || [];
			if (!args.includes("--start-maximized") && !args.includes("--start-fullscreen")) {
				args.push("--start-maximized");
			}
			capabilities[key] ??= {};
			capabilities[key].args = args;
		}
		return capabilities;
	}
	async openPage(_sessionId, url) {
		const browserInstance = await this.openBrowser();
		await browserInstance.url(url);
	}
	async close() {
		await Promise.all([this.browser?.sessionId ? this.browser?.deleteSession?.() : null]);
		process.exit();
	}
}

export { PlaywrightBrowserProvider as P, WebdriverBrowserProvider as W };
