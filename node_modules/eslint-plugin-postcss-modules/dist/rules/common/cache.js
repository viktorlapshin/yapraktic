"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cache = exports.nodeIsMemberExpression = exports.nodeIsImportNamespaceSpecifier = exports.nodeIsImportDefaultSpecifier = exports.nodeIsImportSpecifier = exports.nodeIsImportDeclaration = void 0;
const tslib_1 = require("tslib");
const anymatch_1 = tslib_1.__importDefault(require("anymatch"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const settings_1 = tslib_1.__importDefault(require("../../settings"));
const parser_1 = tslib_1.__importDefault(require("../../parser"));
exports.nodeIsImportDeclaration = (node) => node.type === "ImportDeclaration";
exports.nodeIsImportSpecifier = (node) => node.type === "ImportSpecifier";
exports.nodeIsImportDefaultSpecifier = (node) => node.type === "ImportDefaultSpecifier";
exports.nodeIsImportNamespaceSpecifier = (node) => node.type === "ImportNamespaceSpecifier";
exports.nodeIsMemberExpression = (node) => node.type === "MemberExpression";
class Cache {
    constructor(context) {
        this.settings = new settings_1.default(context);
        this.parser = new parser_1.default(this.settings);
        this.specifierToClasses = {};
    }
    static clear() {
        Cache.filenameToParseResult = {};
    }
    processImportDeclaration(node) {
        if (!exports.nodeIsImportDeclaration(node) ||
            typeof node.source.value !== "string") {
            return null;
        }
        const baseFilename = node.source.value;
        const filename = this.settings.resolveFile(baseFilename);
        if (!anymatch_1.default(this.settings.include, filename) ||
            anymatch_1.default(this.settings.exclude, filename) ||
            !fs_1.default.existsSync(filename)) {
            return null;
        }
        const explicitImports = [];
        let specifier = null;
        node.specifiers.forEach((spec) => {
            if (exports.nodeIsImportSpecifier(spec)) {
                explicitImports.push(spec);
            }
            else if (exports.nodeIsImportDefaultSpecifier(spec) ||
                exports.nodeIsImportNamespaceSpecifier(node)) {
                specifier = spec.local.name;
            }
        });
        const result = Cache.filenameToParseResult[filename] !== undefined
            ? Cache.filenameToParseResult[filename]
            : this.parser.parse(filename);
        if (specifier) {
            this.specifierToClasses[specifier] = {
                filename,
                classes: result.classes,
            };
        }
        if (Cache.filenameToParseResult[filename] === undefined) {
            Cache.filenameToParseResult[filename] = result;
        }
        return {
            node,
            filename,
            specifier,
            explicitImports,
            ...result,
        };
    }
    processMemberExpression(node) {
        if (!exports.nodeIsMemberExpression(node)) {
            return null;
        }
        const objectName = node.object.name;
        if (this.specifierToClasses[objectName] === undefined) {
            return null;
        }
        const { filename, classes } = this.specifierToClasses[objectName];
        const className = node.computed
            ? node.property.value
            : node.property.name;
        if (!className) {
            return null;
        }
        return {
            node,
            filename,
            className: className.toString(),
            classes,
        };
    }
}
exports.Cache = Cache;
Cache.filenameToParseResult = {};
