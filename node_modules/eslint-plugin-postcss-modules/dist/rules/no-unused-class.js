"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.joinClassNames = void 0;
const common_1 = require("./common");
function joinClassNames(classes) {
    if (classes.length === 1) {
        return classes[0];
    }
    if (classes.length === 2) {
        return classes.join(" and ");
    }
    classes[classes.length - 1] = `and ${classes[classes.length - 1]}`;
    return classes.join(", ");
}
exports.joinClassNames = joinClassNames;
exports.default = common_1.createRule({
    description: "Ensures that all of the class exported by a css file are used.",
    messages: {
        unusedClassName: "Class {{ classNames }} is exported but unused.",
        unusedClassNames: "Classes {{ classNames }} are exported but unused.",
    },
    create: (context) => {
        const cache = new common_1.Cache(context);
        const filenameToUnusedClasses = {};
        return {
            Program: () => {
                common_1.Cache.clear();
            },
            ImportDeclaration: (node) => {
                const result = cache.processImportDeclaration(node);
                if (result === null) {
                    return;
                }
                const { node: importNode, filename, classes, explicitImports, usedClasses, } = result;
                const unusedClasses = filenameToUnusedClasses[filename] !== undefined
                    ? filenameToUnusedClasses[filename].unusedClasses
                    : new Set(classes.keys());
                explicitImports.forEach((node) => {
                    var _a;
                    const className = node.imported.name;
                    (_a = classes.get(className)) === null || _a === void 0 ? void 0 : _a.forEach((cn) => unusedClasses.delete(cn));
                    unusedClasses.delete(className);
                });
                if (filenameToUnusedClasses[filename] === undefined) {
                    usedClasses.forEach((used) => unusedClasses.delete(used));
                    filenameToUnusedClasses[filename] = {
                        importNode,
                        unusedClasses,
                    };
                }
            },
            MemberExpression: (node) => {
                var _a;
                const result = cache.processMemberExpression(node);
                if (result === null) {
                    return;
                }
                const { filename, className, classes } = result;
                if (filenameToUnusedClasses[filename]) {
                    const unusedClasses = filenameToUnusedClasses[filename].unusedClasses;
                    (_a = classes.get(className)) === null || _a === void 0 ? void 0 : _a.forEach((cn) => unusedClasses.delete(cn));
                    unusedClasses.delete(className);
                }
            },
            "Program:exit": () => {
                Object.keys(filenameToUnusedClasses).forEach((filename) => {
                    const { importNode, unusedClasses } = filenameToUnusedClasses[filename];
                    if (unusedClasses.size > 0) {
                        const classNames = joinClassNames(Array.from(unusedClasses));
                        context.report({
                            messageId: unusedClasses.size === 1
                                ? "unusedClassName"
                                : "unusedClassNames",
                            node: importNode,
                            data: {
                                classNames,
                            },
                        });
                    }
                });
            },
        };
    },
});
